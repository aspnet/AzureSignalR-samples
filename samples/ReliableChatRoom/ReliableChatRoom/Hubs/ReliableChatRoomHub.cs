using Microsoft.AspNetCore.SignalR;
using Microsoft.Azure.Documents;
using Microsoft.Azure.SignalR.Samples.ReliableChatRoom.Entities;
using Microsoft.Azure.SignalR.Samples.ReliableChatRoom.Factory;
using Microsoft.Azure.SignalR.Samples.ReliableChatRoom.Handlers;
using Microsoft.Azure.SignalR.Samples.ReliableChatRoom.Storage;
using Microsoft.Extensions.Logging;
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.Runtime.InteropServices.WindowsRuntime;
using System.Threading;
using System.Threading.Tasks;

namespace Microsoft.Azure.SignalR.Samples.ReliableChatRoom.Hubs
{
    public class ReliableChatRoomHub : Hub
    {
        private readonly ILogger _logger;

        private readonly IUserHandler _userHandler;
        private readonly IMessageStorage _messageStorage;
        private readonly IMessageFactory _messageFactory;
        private readonly IClientAckHandler _clientAckHandler;
        private readonly INotificationHandler _notificationHandler;

        private readonly DateTime _defaultDateTime = new DateTime(1970, 1, 1);


        public ReliableChatRoomHub(
            ILogger<ReliableChatRoomHub> logger,
            IUserHandler userHandler,
            IMessageStorage messageStorage,
            IMessageFactory messageFactory,
            IClientAckHandler clientAckHandler,
            INotificationHandler notificationHandler)
        {
            _logger = logger;
            _userHandler = userHandler;
            _messageStorage = messageStorage;
            _messageFactory = messageFactory;
            _clientAckHandler = clientAckHandler;
            _notificationHandler = notificationHandler;
        }

        /// <summary>
        /// Hub method. Called everytime when client trys to log into hub with a new (or expired) session.
        /// </summary>
        /// <param name="deviceUuid">A random id of client device, used for notification service</param>
        /// <param name="username">The username of client</param>
        /// <returns></returns>
        public async Task<string> EnterChatRoom(string deviceUuid, string username)
        {
            _logger.LogInformation("EnterChatRoom device: {0} username: {1}", deviceUuid, username);
            
            //  Try to store user login information (ConnectionId & deviceUuid)
            Session session = _userHandler.Login(username, Context.ConnectionId, deviceUuid);
            
            //  If login was successful, broadcast the system message 
            if (session != null)
            {
                Message loginMessage = _messageFactory.CreateSystemMessage(username, "joined", DateTime.UtcNow);
                //  Do not store system messages. Directly send them out.
                await SendSystemMessage(loginMessage);
                return "success";
            } else
            {
                return "failure";
            }
        }

        /// <summary>
        /// Hub method. Called everytime when client trys to ping the server to extend his/her session and stay alive.
        /// </summary>
        /// <param name="deviceUuid">A random id of client device, used for notification service (may be a new id)</param>
        /// <param name="username">The username of client</param>
        /// <returns></returns>
        public async Task TouchServer(string deviceUuid, string username)
        {
            DateTime touchedDateTime = _userHandler.Touch(username, Context.ConnectionId, deviceUuid);
            if (touchedDateTime == _defaultDateTime) //  Session either does not exist or has expired
            {
                // Force the client to expire session and re-login
                await Clients.Caller.SendAsync("expireSession", true);
            }
        }

        /// <summary>
        /// Hub method. Called when client explicitly quits the chat room.
        /// </summary>
        /// <param name="deviceUuid">A random id of client device, used for notification service (may be a new id)</param>
        /// <param name="username">The username of client</param>
        /// <returns></returns>
        public async Task<string> LeaveChatRoom(string deviceUuid, string username)
        {
            _logger.LogInformation("LeaveChatRoom username: {0}", username);

            //  Do not care about logout result.
            Session session = _userHandler.Logout(username);

            //  Broadcast the system message.
            Message logoutMessage = _messageFactory.CreateSystemMessage(username, "left", DateTime.UtcNow);
            
            //  Do not store system messages. Directly send them out.
            await SendSystemMessage(logoutMessage);

            return "success";
        }

        /// <summary>
        /// Hub method. Called when client sends a broadcast message.
        /// </summary>
        /// <param name="messageId">The messageId generated by client side</param>
        /// <param name="sender">The client who send the message</param>
        /// <param name="payload">The message content. Can be string / binary object in base64</param>
        /// <param name="isImage">Whether incoming message is an image message</param>
        /// <returns></returns>
        public async Task OnBroadcastMessageReceived(string messageId, string sender, string payload, bool isImage)
        {
            _logger.LogInformation("OnBroadcastMessageReceived {0} {1} payload size={2}", messageId, sender, payload.Length);

            //  Create message
            Message message = _messageFactory.CreateBroadcastMessage(messageId, sender, payload, isImage, DateTime.UtcNow);

            // Send back server ack without waiting for method result
            long receivedTimeInLong = CSharpDateTimeToJavaLong(message.SendTime);
            _ = Clients.Client(Context.ConnectionId).SendAsync("serverAck", message.MessageId, receivedTimeInLong);

            //  Try to store the message 
            bool success = await _messageStorage.TryStoreMessageAsync(message);

            //  Only send messages out when storage was a success
            if (success)
            {
                await SendBroadCastMessage(message);
            }
        }

        /// <summary>
        /// Hub method. Called when client sends a private message.
        /// </summary>
        /// <param name="messageId">The messageId generated by client side</param>
        /// <param name="sender">The client who sends the message</param>
        /// <param name="receiver">The client who receives the message</param>
        /// <param name="payload">The message content. Can be string / binary object in base64</param>
        /// <param name="isImage">Whether incoming message is an image message</param>
        /// <returns></returns>
        public async Task OnPrivateMessageReceived(string messageId, string sender, string receiver, string payload, bool isImage)
        {

            _logger.LogInformation("OnPrivateMessageReceive {0} {1} {2} payload size={3}", messageId, sender, receiver, payload.Length);

            //  Create message and send back server ack
            Message message = _messageFactory.CreatePrivateMessage(messageId, sender, receiver, payload, isImage, DateTime.UtcNow);

            // Send back server ack without waiting for result
            long receivedTimeInLong = CSharpDateTimeToJavaLong(message.SendTime);
            _ = Clients.Client(Context.ConnectionId).SendAsync("serverAck", message.MessageId, receivedTimeInLong);

            //  Try to store the message
            bool success = await _messageStorage.TryStoreMessageAsync(message);

            //  Only send messages out when storage was a success
            if (success)
            {
                await SendPrivateMessage(message);
            }
        }

        /// <summary>
        /// Hub method. Called when client sends back an ACK on any message.
        /// </summary>
        /// <param name="clientAckId">The unique id representing a ClientAck object</param>
        /// <param name="username">The ack sender's username</param>
        public void OnAckResponseReceived(string clientAckId, string username)
        {
            _logger.LogInformation("OnAckResponseReceived clientAckId: {0}", clientAckId);
            
             //  Complete the waiting client ack object
            _clientAckHandler.Ack(clientAckId, username);
        }

        /// <summary>
        /// Hub method. Called when client broadcasts his/her read status on a specific message.
        /// Be advised. Only <see cref="MessageTypeEnum.Private"/> messages have status of read.
        /// </summary>
        /// <param name="messageId">The messageId generated by client side</param>
        /// <param name="username">The username of the client</param>
        /// <returns></returns>
        public async Task OnReadResponseReceived(string messageId, string username)
        {
            _logger.LogInformation(string.Format("OnReadResponseReceived messageId: {0}; username: {1}", messageId, username));

            //  Try to set read and store the message
            Message message = await _messageStorage.TryFetchMessageById(messageId);
            message.IsRead = true;
            bool success = await _messageStorage.TryUpdateMessageAsync(message);

            //  Only send messages out when storage was a success
            if (success)
            {
                //  Broadcast message read by user
                await Clients.Client(_userHandler.GetUserSession(message.Sender).ConnectionId)
                    .SendAsync("clientRead", messageId, username);
            }
        }

        /// <summary>
        /// Hub method. Called when client requests to pull his/her history message.
        /// </summary>
        /// <param name="username">The username of the client</param>
        /// <param name="untilTime">The earliest message stored on the client. Any message
        /// after the untilTime will not be pulled</param>
        /// <returns></returns>
        public async Task OnPullHistoryMessagesReceived(string username, long untilTime)
        {
            _logger.LogInformation(string.Format("OnPullHistoryMessageReceived username: {0}; until: {1}", username, untilTime));

            //  Convert java base client time to C# DateTime object
            var untilDateTime = JavaLongToCSharpDateTime(untilTime);

            //  Fetch history from message storage. After done, send them back with a callback method SendHistoryMessages.
            List<Message> historyMessages = new List<Message>();
            bool success = await _messageStorage.TryFetchHistoryMessageAsync(username, untilDateTime, historyMessages);

            //  Only send messages out when storage was a success
            if (success)
            {
                await SendHistoryMessages(historyMessages);
            }
        }

        /// <summary>
        /// Hub method. Called when client wants to fetch the content of an image message.
        /// </summary>
        /// <param name="username"></param>
        /// <param name="messageId"></param>
        /// <returns></returns>
        public async Task OnPullImageContentReceived(string username, string messageId)
        {
            _logger.LogInformation(string.Format("OnPullImageContentReceived username: {0}; messageId: {1}", username, messageId));

            string imagePayload = await _messageStorage.TryFetchImageContentAsync(messageId);

            await Clients.Client(_userHandler.GetUserSession(username).ConnectionId).SendAsync("receiveImageContent", messageId, imagePayload);
        }

        /// <summary>
        /// Utility method. Sends the passed systemMessage.
        /// </summary>
        /// <param name="systemMessage">System message to send</param>
        /// <returns></returns>
        private async Task SendSystemMessage(Message systemMessage)
        {
            //  Broadcast to all other users
            await Clients.All.SendAsync("receiveSystemMessage",
                    systemMessage.MessageId,
                    systemMessage.Payload,
                    CSharpDateTimeToJavaLong(systemMessage.SendTime));
        }

        /// <summary>
        /// Utility method. Sends broadcast message to clients other than sender
        /// </summary>
        /// <param name="broadcastMessage">Broadcast message to send</param>
        /// <returns>
        /// An Async Task of bool result.
        /// true - Callback was success
        /// false - Callback was failure
        /// </returns>
        private async Task<bool> SendBroadCastMessage(Message broadcastMessage)
        {
            //  Create a client ack 
            var clientAck = _clientAckHandler.CreateClientAck(broadcastMessage);

            //  Send notification first and do not block for result
            _ = _notificationHandler.SendBroadcastNotification(broadcastMessage);

            //  Broadcast to all other users
            try
            {
                await Clients.AllExcept(_userHandler.GetUserSession(broadcastMessage.Sender).ConnectionId)
                    .SendAsync("receiveBroadcastMessage",
                                broadcastMessage.MessageId,
                                broadcastMessage.Sender,
                                broadcastMessage.Receiver,
                                broadcastMessage.Payload,
                                broadcastMessage.IsImage,
                                CSharpDateTimeToJavaLong(broadcastMessage.SendTime),
                                clientAck.ClientAckId);
            } catch (Exception ex)
            {
                _logger.LogError(ex.Message);
                return false;
            }

            return true;            
        }

        /// <summary>
        /// Utility method. Sends private message to the receiver client.
        /// </summary>
        /// <param name="privateMessage">Private message to send</param>
        /// <param name="hubContext">IHubContext to call client methods</param>
        /// <returns>
        /// An Async Task of bool result.
        /// true - Callback was success
        /// false - Callback was failure
        /// </returns>
        private async Task<bool> SendPrivateMessage(Message privateMessage)
        {
            //  Create a client ack 
            var clientAck = _clientAckHandler.CreateClientAck(privateMessage);

            //  Send notification first and do not block for result
            _ = _notificationHandler.SendPrivateNotification(privateMessage);

            try
            {
                //  Send to receiver then
                await Clients.Client(_userHandler.GetUserSession(privateMessage.Receiver).ConnectionId)
                        .SendAsync("receivePrivateMessage",
                                    privateMessage.MessageId,
                                    privateMessage.Sender,
                                    privateMessage.Receiver,
                                    privateMessage.Payload,
                                    privateMessage.IsImage,
                                    CSharpDateTimeToJavaLong(privateMessage.SendTime),
                                    clientAck.ClientAckId);
            } catch (Exception ex)
            {
                _logger.LogError(ex.Message);
                return false;
            }

            return true;
        }

        /// <summary>
        /// Utility method. Sends list of history messages to the requesting client.
        /// </summary>
        /// <param name="historyMessages">List of history messages to send back</param>
        /// <returns>
        /// An Async Task of bool result.
        /// true - Callback was success
        /// false - Callback was failure
        /// </returns>
        private async Task<bool> SendHistoryMessages(List<Message> historyMessages)
        {
            try
            {
                //  Convert list of history messages to jsonString, then send to the client.
                _logger.LogInformation("SendHistoryMessages");
                await Clients.Client(Context.ConnectionId)
                    .SendAsync("receiveHistoryMessages", _messageFactory.ToListJsonString(historyMessages));
            } catch (Exception ex)
            {
                _logger.LogError(ex.Message);
                return false;
            }

            return true;
        }

        /// <summary>
        /// Utility method. Converts java milliseconds in long to C# DateTime object
        /// </summary>
        /// <param name="milliseconds">Java milliseconds in long</param>
        /// <returns></returns>
        private DateTime JavaLongToCSharpDateTime(long milliseconds)
        {
            long ticks = milliseconds * TimeSpan.TicksPerMillisecond + _defaultDateTime.Ticks;
            return new DateTime(ticks);
        }

        /// <summary>
        /// Utility method. Converts C# DateTime object to java milliseconds in long 
        /// </summary>
        /// <param name="dateTime"></param>
        /// <returns></returns>
        private long CSharpDateTimeToJavaLong(DateTime dateTime)
        {
            return (dateTime - _defaultDateTime).Ticks / TimeSpan.TicksPerMillisecond;
        }
    }
}
